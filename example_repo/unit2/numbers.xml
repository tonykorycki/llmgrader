<unit id="numbers" title="Number Formats" version="1.0">
    
    <question qtag="Truncation" preferred_model="gpt-4.1-mini">

        <question_text><![CDATA[
            <p>
                Truncate the following numbers to 4 bits in both unsigned and signed
                representations. Provide the decimal value of the truncated numbers in each case.
            </p>

            <ol type="a">
                <li>9</li>
                <li>15</li>
                <li>23</li>
                <li>-1</li>
                <li>-12</li>
            </ol>
        ]]></question_text>

        <solution><![CDATA[
            <p>
                One method is to convert each decimal number to binary, truncate to 4 bits,
                and convert back to decimal.
            </p>

            <ol type="a">
                <li>Unsigned: <code>1001</code> = 9. Signed: <code>1001</code> = −7.</li>
                <li>Unsigned: <code>1111</code> = 15. Signed: <code>1111</code> = −1.</li>
                <li>Unsigned: <code>0111</code> = 7. Signed: <code>0111</code> = 7.</li>
                <li>Unsigned: <code>1111</code> = 15. Signed: <code>1111</code> = −1.</li>
                <li>Unsigned: <code>0100</code> = 4. Signed: <code>0100</code> = 4.</li>
            </ol>

            <p>
                You can also compute truncated values using modular arithmetic.
                For unsigned numbers, compute the value modulo \(2^4 = 16\).
                For signed numbers, compute modulo 16 and adjust to the signed range \([-8,7]\).
            </p>

            <ol type="a">
                <li>Unsigned: \(9 \bmod 16 = 9\). Signed: \(9 - 16 = -7\).</li>
                <li>Unsigned: \(15 \bmod 16 = 15\). Signed: \(15 - 16 = -1\).</li>
                <li>Unsigned: \(23 \bmod 16 = 7\). Signed: \(7\) is in range.</li>
                <li>Unsigned: \(-1 \bmod 16 = 15\). Signed: \(15 - 16 = -1\).</li>
                <li>Unsigned: \(-12 \bmod 16 = 4\). Signed: \(4\) is in range.</li>
            </ol>
        ]]></solution>

        <grading_notes><![CDATA[
            - No explanation is required if the decimal values are correct.

        ]]></grading_notes>
        <grade>false</grade>
        <parts>
            <part>
                <part_label>a</part_label>
                <points>2</points>
            </part>
            <part>
                <part_label>b</part_label>
                <points>2</points>
            </part>
            <part>
                <part_label>c</part_label>
                <points>2</points>
            </part>
            <part>
                <part_label>d</part_label>
                <points>2</points>
            </part>
            <part>
                <part_label>e</part_label>
                <points>2</points>
            </part>
        </parts>

    </question>

    <question qtag="Addition overflow" preferred_model="gpt-4.1-mini">

        <question_text><![CDATA[
            <p>Consider the addition:</p>

            <pre><code>
            logic signed [3:0] a = A;
            logic signed [3:0] b = B;
            logic signed [W-1:0] c;
            c = a + b;
            </code></pre>

            <p>
                For each of the following values of <code>A</code>, <code>B</code>, and <code>W</code>,
                determine the value of <code>c</code> in decimal.
            </p>

            <ol type="a">
                <li><code>A = 5, B = 3, W = 4</code></li>
                <li><code>A = 5, B = 4, W = 4</code></li>
                <li><code>A = 9, B = -7, W = 5</code></li>
            </ol>
        ]]></question_text>

        <solution><![CDATA[
            <ol type="a">
                <li>
                    Both literals fit in the 4‑bit signed range (−8 to +7).
                    The addition produces a 5‑bit result of 8, which fits in 4 bits.
                    Thus, <code>c = 8</code>.
                </li>

                <li>
                    Both literals fit in 4 bits. The addition produces a 5‑bit result of 9.
                    Assigning to a 4‑bit signed vector truncates the value:
                    \(c = 9 \bmod 16 = 9 - 16 = -7\).
                </li>

                <li>
                    Literal 9 does not fit in the 4‑bit signed range.
                    It is truncated to <code>1001</code> = −7.
                    Thus the addition is −7 + (−7) = −14, which fits in 5 bits.
                    <code>c = -14</code>.
                </li>
            </ol>
        ]]></solution>

        <grading_notes><![CDATA[
            Common mistakes include:
            - Forgetting that assigning a literal to a packed vector truncates it to the vector’s width.
            - Assuming the addition itself overflows in 4 bits; SystemVerilog computes the sum in a wider temporary (max width + 1).
            - Confusing truncation with sign‑extension when assigning the result to c.
            - Missing that in part (c), the literal 9 already overflows when stored in a 4‑bit signed vector, becoming -7 before the addition.

            Any clear explanation or direct computation is acceptable.
            Answers may be given in decimal only; binary working is optional.
            No explanation is required as long as the final decimal values are correct.
        ]]></grading_notes>

        <grade>false</grade>

        <parts>
            <part>
                <part_label>a</part_label>
                <points>2</points>
            </part>
            <part>
                <part_label>b</part_label>
                <points>2</points>
            </part>
            <part>
                <part_label>c</part_label>
                <points>2</points>
            </part>
        </parts>

    </question>
    <question qtag="Addition with multiple numbers" preferred_model="gpt-4.1-mini">

        <question_text><![CDATA[
            <p>Consider the addition:</p>

            <pre><code>
            logic signed [7:0] a, b, c, d;
            logic signed [W-1:0] sum = a + b + c + d;
            </code></pre>

            <p>
                What value of <code>W</code> is required to ensure that no overflow
                occurs in the sum?
            </p>
        ]]></question_text>

        <solution><![CDATA[
            <p>
                The partial sums <code>a + b</code> and <code>c + d</code> each require one
                extra bit, so they need \(8 + 1 = 9\) bits.
                Adding these two 9‑bit partial sums requires one more extra bit,
                so the final sum requires:  <code>W = 9 + 1=10</code>.
            </p>
        ]]></solution>

        <grading_notes><![CDATA[
            Common mistakes include:
            - Forgetting that each 8-bit signed addition requires one extra bit (width = 8 + 1 = 9).
            - Assuming that adding four numbers requires only one extra bit total, rather than one extra bit per addition stage.
            - Assuming that each multiplication requires one extra bit, so adding 3 extra bits instead of 2,
            forgetting that a+b and c+d can each be done in 9 bits, and only their sum needs an extra bit.
            - Missing that the expression is evaluated left-to-right, but any valid reasoning about partial sums is acceptable.
            - Incorrectly concluding that W = 9 instead of W = 10.

            Any clear explanation or correct reasoning is acceptable.
            Students may compute partial sums in any order.
            No explanation is required as long as the final answer W = 10 is correct.
        ]]></grading_notes>
        <grade>false</grade>
        <parts>
            <part>
                <part_label>all</part_label>
                <points>5</points>
            </part>
        </parts>

    </question>

    <question qtag="Multiplication overflow" preferred_model="gpt-4.1-mini">

        <question_text><![CDATA[
            <p>Consider the multiplication:</p>

            <pre><code>
            logic signed [3:0] a = A;
            logic signed [3:0] b = B;
            logic signed [W-1:0] c;
            c = a * b;
            </code></pre>

            <p>
                For each of the following values of <code>A</code>, <code>B</code>, and <code>W</code>,
                determine the value of <code>c</code> in decimal.
            </p>

            <ol type="a">
                <li><code>A = 3, B = 4, W = 6</code></li>
                <li><code>A = 7, B = 7, W = 5</code></li>
                <li><code>A = -9, B = 5, W = 6</code></li>
            </ol>
        ]]></question_text>

        <solution><![CDATA[
            <ol type="a">

                <li>
                    Both literals fit in the 4‑bit signed range (−8 to +7).
                    The product is \(3 \times 4 = 12\), which fits in 6 bits.
                    Thus, <code>c = 12</code>.
                </li>

                <li>
                    Both literals fit in 4 bits. The product is \(7 \times 7 = 49\).
                    Assigning to a 5‑bit signed vector truncates modulo \(2^5 = 32\):
                    \(49 \bmod 32 = 17\).
                    Since 17 is in the signed 5‑bit range (−16 to +15),
                    it is interpreted as \(17 - 32 = -15\).
                    Thus, <code>c = -15</code>.
                </li>

                <li>
                    Literal −9 does not fit in 4 bits and is truncated to
                    <code>0111</code> = 7.
                    The multiplication is therefore \(7 \times 5 = 35\).
                    Assigning to a 6‑bit signed vector truncates modulo \(2^6 = 64\):
                    \(35\) is already in range (−32 to +31),
                    so <code>c = 35</code>.
                </li>

            </ol>
        ]]></solution>

        <grading_notes><![CDATA[
            Common mistakes include:
            - Forgetting that assigning a literal to a packed vector truncates it to the vector’s width.
            - Assuming the multiplication is performed in the destination width; SystemVerilog computes the product in a wider temporary (sum of operand widths).
            - Confusing truncation with sign‑extension when assigning the result to c.
            - Missing that in part (c), the literal -9 overflows when stored in a 4‑bit signed vector, becoming +7 before the multiplication.

            Any clear explanation or direct computation is acceptable.
            Answers may be given in decimal only; binary working is optional.
            No explanation is required as long as the final decimal values are correct.
        ]]></grading_notes>

        <grade>false</grade>

        <parts>
            <part>
                <part_label>a</part_label>
                <points>2</points>
            </part>
            <part>
                <part_label>b</part_label>
                <points>2</points>
            </part>
            <part>
                <part_label>c</part_label>
                <points>2</points>
            </part>
        </parts>

    </question>

    <question qtag="Custom FP decoding" preferred_model="gpt-4.1-mini">
        <question_text><![CDATA[
        <p>
        Consider a simple floating‑point representation \( x = A \, (-1)^s \, c \, 2^e \),
        where the scale factor is \(A = 2^{-3}\).
        The fields are:
        <ul>
            <li>sign bit \(s\)</li>
            <li>3‑bit unsigned exponent \(e\)</li>
            <li>5‑bit mantissa \(c\), interpreted as an <em>unsigned integer</em> (no implicit leading 1)</li>
        </ul>
        </p>

        <p>
            The bits are packed with the sign bit first, followed by the exponent bits,
            then the mantissa bits.  
            What decimal values are represented by the following bit patterns?
        </p>

        <ol type="a">
            <li><code>0 000 10000</code></li>
            <li><code>1 011 11000</code></li>
            <li><code>0 101 00101</code></li>
        </ol>
        ]]></question_text>

        <solution><![CDATA[
        <ol type="a">

            <li>
                Sign bit \(s = 0\) → positive.  
                Exponent bits \(000\) → \(e = 0\).  
                Mantissa bits \(10000_2 = 16\).  
                Value:
                \[
                    x = 2^{-3} \cdot (+1) \cdot 16 \cdot 2^0
                    = 2^{-3} \cdot 16
                    = 2
                \]
            </li>

            <li>
                Sign bit \(s = 1\) → negative.  
                Exponent bits \(011\) → \(e = 3\).  
                Mantissa bits \(11000_2 = 24\).  
                Value:
                \[
                    x = 2^{-3} \cdot (-1) \cdot 24 \cdot 2^3
                    = (-1) \cdot 24
                    = -24
                \]
            </li>

            <li>
                Sign bit \(s = 0\) → positive.  
                Exponent bits \(101\) → \(e = 5\).  
                Mantissa bits \(00101_2 = 5\).  
                Value:
                \[
                    x = 2^{-3} \cdot (+1) \cdot 5 \cdot 2^5
                    = 2^{-3} \cdot 160
                    = 20
                \]
            </li>

        </ol>
        ]]></solution>
        <grading_notes><![CDATA[
        - Students may forget to apply the scale factor \(A = 2^{-3}\); this is the most common error.
        - It is acceptable to compute values in any order as long as the final decimal answers are correct.
        - No explanation is required if the final numerical values are correct.
        ]]></grading_notes>
        <grade>false</grade>

        <parts>
            <part>
                <part_label>a</part_label>
                <points>2</points>
            </part>
            <part>
                <part_label>b</part_label>
                <points>2</points>
            </part>
            <part>
                <part_label>c</part_label>
                <points>2</points>
            </part>
        </parts>
    </question> 

    <question qtag="Custom FP encoding" preferred_model="gpt-4.1-mini">

        <question_text><![CDATA[
            <p>
                Consider a custom floating-point format
                \[
                    \hat{x} = (-1)^s \left(1 + \frac{c}{2^p}\right) 2^{e - 4},
                \]
                where:
            </p>
            <ul>
                <li>\(s\) is a 1-bit sign (\(s \in \{0,1\}\)),</li>
                <li>\(c\) is a \(p = 5\)-bit unsigned mantissa field (\(c \in \{0,\dots,31\}\)),</li>
                <li>\(e\) is a 3-bit unsigned exponent field (\(e \in \{0,\dots,7\}\)).</li>
            </ul>

            <p>
                For each real number \(x\) below, choose \(s\), \(c\), and \(e\) so that
                \(\hat{x}\) is as close as possible to \(x\). Give your final answers as
                \((s, c, e)\) and the corresponding \(\hat{x}\) in decimal.
            </p>

            <ol type="a">
                <li>\(x = 3.0\)</li>
                <li>\(x = 0.5\)</li>
                <li>\(x = -5.0\)</li>
                <li>\(x = 1.3\)</li>
            </ol>
        ]]></question_text>

        <solution><![CDATA[
            <p>
                In all cases, we write \(|x|\) in the form
                \[
                    |x| = \left(1 + \frac{c}{32}\right) 2^{e - 4},
                \]
                with \(c \in \{0,\dots,31\}\), \(e \in \{0,\dots,7\}\), and choose \(s = 0\) for \(x \ge 0\),
                \(s = 1\) for \(x < 0\). When \(|x|\) is not exactly representable, we choose \(c\) to make
                \(\hat{x}\) closest to \(x\).
            </p>

            <ol type="a">

                <li>
                    <strong>\(x = 3.0\)</strong><br>
                    We write \(3.0 = 1.5 \cdot 2^1\). Thus the normalized form has
                    \(1 + \frac{c}{32} = 1.5\) and \(e - 4 = 1\).<br>
                    So \(e = 5\) and \(\frac{c}{32} = 0.5 \Rightarrow c = 16\). The value is exact:
                    \[
                        \hat{x} = (+1)\left(1 + \frac{16}{32}\right)2^{5-4}
                            = 1.5 \cdot 2
                            = 3.0.
                    \]
                    Since \(x > 0\), \(s = 0\).<br>
                    Answer: \((s, c, e) = (0, 16, 5)\), \(\hat{x} = 3.0\).
                </li>

                <li>
                    <strong>\(x = 0.5\)</strong><br>
                    We write \(0.5 = 1.0 \cdot 2^{-1}\). Thus \(1 + \frac{c}{32} = 1.0\) and \(e - 4 = -1\).<br>
                    So \(e = 3\) and \(\frac{c}{32} = 0 \Rightarrow c = 0\). The value is exact:
                    \[
                        \hat{x} = (+1)\left(1 + \frac{0}{32}\right)2^{3-4}
                            = 1 \cdot 2^{-1}
                            = 0.5.
                    \]
                    Since \(x > 0\), \(s = 0\).<br>
                    Answer: \((s, c, e) = (0, 0, 3)\), \(\hat{x} = 0.5\).
                </li>

                <li>
                    <strong>\(x = -5.0\)</strong><br>
                    First use \(|x| = 5.0\). We write \(5.0 = 1.25 \cdot 2^2\). Thus
                    \(1 + \frac{c}{32} = 1.25\) and \(e - 4 = 2\).<br>
                    So \(e = 6\) and \(\frac{c}{32} = 0.25 \Rightarrow c = 8\). The magnitude is exact:
                    \[
                        |\hat{x}| = \left(1 + \frac{8}{32}\right)2^{6-4}
                                = 1.25 \cdot 4
                                = 5.0.
                    \]
                    Since \(x < 0\), \(s = 1\).<br>
                    Answer: \((s, c, e) = (1, 8, 6)\), \(\hat{x} = -5.0\).
                </li>

                <li>
                    <strong>\(x = 1.3\)</strong><br>
                    We write \(1.3 = 1.3 \cdot 2^0\), so \(e - 4 = 0 \Rightarrow e = 4\). We need
                    \[
                        1 + \frac{c}{32} \approx 1.3
                        \quad\Rightarrow\quad
                        \frac{c}{32} \approx 0.3
                        \quad\Rightarrow\quad
                        c \approx 0.3 \cdot 32 = 9.6.
                    \]
                    The nearest integers are \(c = 9\) and \(c = 10\):
                    \[
                        c = 9  \Rightarrow 1 + \frac{9}{32}  = 1.28125,\quad
                        c = 10 \Rightarrow 1 + \frac{10}{32} = 1.3125.
                    \]
                    Distances:
                    \(|1.3 - 1.28125| = 0.01875,\quad |1.3 - 1.3125| = 0.0125.\)
                    So \(c = 10\) gives the closer value. With \(e = 4\),
                    \[
                        \hat{x} = (+1)\left(1 + \frac{10}{32}\right)2^{4-4}
                            = 1.3125.
                    \]
                    Since \(x > 0\), \(s = 0\).<br>
                    Answer: \((s, c, e) = (0, 10, 4)\), \(\hat{x} = 1.3125\).
                </li>

            </ol>
        ]]></solution>

        <grading_notes><![CDATA[
            - Students may forget that the mantissa is of the form \(1 + c/2^5\), not just \(c/2^5\).
            - Students may also forget the exponent bias of 4 in the term \(2^{e-4}\).
            - Any correct method of choosing \(s\), \(c\), and \(e\) that yields the closest \(\hat{x}\) is acceptable.
            - No explanation is required if the final (s, c, e) and corresponding decimal \(\hat{x\)} are correct.
        ]]></grading_notes>

        <parts>
            <part>
                <part_label>a</part_label>
                <points>2</points>
            </part>
            <part>
                <part_label>b</part_label>
                <points>2</points>
            </part>
            <part>
                <part_label>c</part_label>
                <points>2</points>
            </part>
            <part>
                <part_label>d</part_label>
                <points>2</points>
            </part>
        </parts>

    </question>

    <question qtag="FixP linear approximation" preferred_model="gpt-4.1-mini">

        <question_text><![CDATA[
            <p>
                You wish to approximate the floating‑point equation
                \[
                    y = a x + b
                \]
                using Qm.n fixed‑point arithmetic.
            </p>

            <p>
                Let \(a = 0.3125\), \(b = -1.75\), and choose the format Q3.4
                (3 integer bits including sign, 4 fractional bits).
            </p>
            <ol type="a">
                <li>Convert \(a\) and \(b\) into their Q3.4 integer representations.</li>
                <li>Write SystemVerilog code that computes an approximation of \(y\) using only Q3.4 arithmetic.</li>
            </ol>
        ]]></question_text>

        <solution><![CDATA[
            <p><strong>Part a:</strong> Convert coefficients to Q3.4.
                In Q3.4, a real number \(x\) is represented as
                \[
                    x_{\text{int}} = \text{round}(x \cdot 2^4).
                \]
            </p>

            <ul>
                <li>
                    \(a = 0.3125\):  
                    \(a_{\text{int}} = 0.3125 \cdot 16 = 5\)
                </li>
                <li>
                    \(b = -1.75\):  
                    \(b_{\text{int}} = -1.75 \cdot 16 = -28\)
                </li>
            </ul>

            <p><strong>Part b:</strong> SystemVerilog implementation</p>

            <pre><code>
            logic signed [7:0] aint = 5;      // Q3.4 representation of a
            logic signed [7:0] bint = -28;    // Q3.4 representation of b
            logic signed [7:0] xint;          // Q3.4 input
            logic signed [7:0] yint;          // Q3.4 output

            yint = ((aint * xint) >>> 4) + bint;
            </code></pre>

            <p>
                The multiplication <code>aint * xint</code> produces a Q6.8 intermediate.
                Shifting right by 4 bits returns the result to Q3.4 format.
            </p>
        ]]></solution>

        <grading_notes><![CDATA[
            - Students may forget that converting to Q3.4 requires multiplying by \(2^4 = 16\).
            - Students may also forget to shift right by n bits after multiplication.
            - Any correct Qm.n implementation of \(y = ax + b\) is acceptable.
            - No explanation is required if the final integer values and SystemVerilog expression are correct.
        ]]></grading_notes>
        <grade>true</grade>
        <parts>
            <part>
                <part_label>a</part_label>
                <points>5</points>
            </part>
            <part>
                <part_label>b</part_label>
                <points>5</points>
            </part>
        </parts>

    </question>

    <question qtag="FixedP mult with saturation" preferred_model="gpt-4.1-mini">

    <question_text><![CDATA[
        <p>
            Write SystemVerilog code to implement the computation
            \[
                y = a \cdot b
            \]
            where all variables (<code>a</code>, <code>b</code>, and <code>y</code>) are represented in Q5.4 format.
            The multiplication must be performed in full precision. Before assigning the result to
            <code>y</code>, saturate the value if it overflows the representable Q5.4 range.
            Note:  You will want to save the product in a wider intermediate variable
            before saturation.
        </p>
        ]]></question_text>

        <solution><![CDATA[
            <p> Let <code>N = 4</code> be the number of fractional bits
            and <code>W = 9</code> be the total width of Q5.4 values
            (5 integer bits including sign, 4 fractional bits).
            Multiplication will require <code>2*W=18</code> bits for full precision,
            followed by a right shift of <code>N=4</code> bits, so the product
            after right shifting requires <code>2*W-N=14</code> bits.
            The final saturation step maps this back to <code>W=9</code> bits,
            so we need check for overflow at <code>(1<< (W-1)) - 1 = 255</code> and
            <code>-(1<< (W-1)) = -256</code>.  One code to perform these steps is
            as follows.  Note that I have used the keyword 
            </code>localparams</code> to define constants that can be computed
            at elaboration time.  If you do not use this keyword, you will
            receive full credit.</p>

            <pre><code>
            localparam int N = 4;     // fractional bits
            localparam int W = 9;     // Q5.4 total width

            logic signed [W-1:0] a, b, y;
            logic signed [2*W-1:0] prod;  

            // Full-precision product
            prod = a * b;

            // Right shift by N
            logic signed [2*W-N-1:0] y_raw = prod >> N;

            // Saturation limits for Q5.4
            localparam logic signed [W-1:0] MAX_Q =  (1 <<< (W-1)) - 1;
            localparam logic signed [W-1:0] MIN_Q = -(1 <<< (W-1));

            // Overflow detection and saturation
            if (y_raw > MAX_Q)
                y = MAX_Q;
            else if (y_raw < MIN_Q)
                y = MIN_Q;
            else
                y = y_raw;
            </code></pre>
        ]]></solution>

        <grading_notes><![CDATA[
            - It is OK if students do not use localparams for N and W, as long as the values are correct.
            - It is OK if students hard code the values for the derived widths and
            saturation limits, as long as they are correct.
            - It is OK if students skip the intermediate variables such as <code>prod</code> and <code>y_raw</code>,
            as long as the overall logic is correct.  For example, they may combine steps into a single expression
            for <code>y_raw = ((a*b)>>N)</code>.
            - The saturation could also be performed before the right shift by <code>N</code> with 
            <code>W+N</code> bits.
            - Saturation can be performed using < and > instead of <= and >=.
            The behavior is the same.
            - The widths for the Q_MAX and Q_MIN can be greater than W-1.
            In particular, they can be the same width as y_raw (2*W-N-1).
            - Students may forget that multiplying two Q5.4 values produces a wider intermediate that must be shifted right by 4 bits.
            - Students may also forget to apply saturation after scaling.
            - Any correct implementation of full-precision multiply, shift, overflow detection, and saturation is acceptable.
            - No explanation is required if the SystemVerilog code is correct.
        ]]></grading_notes>
        <grade>true</grade>
        <parts>
            <part>
                <part_label>all</part_label>
                <points>10</points>
            </part>
        </parts>

    </question>
</unit>
